// Copyright 2020 Parity Technologies (UK) Ltd.
// This file is part of Substrate.

// Substrate is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Substrate is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Substrate.  If not, see <http://www.gnu.org/licenses/>.

//! # Intel SGX Enclave Hello World

#![cfg_attr(not(feature = "std"), no_std)]

use frame_support::{debug, decl_module, decl_storage, decl_event};
use frame_system::{self as system, offchain};
use sp_core::crypto::KeyTypeId;
use sp_runtime::{
	offchain::http,
	transaction_validity::{InvalidTransaction, TransactionValidity, TransactionSource}
};
use sp_std::vec::Vec;
use sp_std::*;

#[cfg(test)]
mod tests;

/// Defines application identifier for crypto keys of this module.
pub const KEY_TYPE: KeyTypeId = KeyTypeId(*b"sgx!");

pub mod crypto {
	use crate::KEY_TYPE;
	use sp_core::sr25519::Signature as Sr25519Signature;
	use sp_runtime::{
		app_crypto::{app_crypto, sr25519},
		traits::Verify,
		MultiSignature, MultiSigner,
	};

	app_crypto!(sr25519, KEY_TYPE);

	pub struct TestAuthId;
	// implemented for ocw-runtime
	impl frame_system::offchain::AppCrypto<MultiSigner, MultiSignature> for TestAuthId {
		type RuntimeAppPublic = Public;
		type GenericSignature = sp_core::sr25519::Signature;
		type GenericPublic = sp_core::sr25519::Public;
	}

	// implemented for mock runtime in test
	impl frame_system::offchain::AppCrypto<<Sr25519Signature as Verify>::Signer, Sr25519Signature>
		for TestAuthId
	{
		type RuntimeAppPublic = Public;
		type GenericSignature = sp_core::sr25519::Signature;
		type GenericPublic = sp_core::sr25519::Public;
	}
}

/// This pallet's configuration trait
pub trait Trait: frame_system::Trait + offchain::CreateSignedTransaction<Call<Self>>  {
	/// The identifier type for an authority.
	type AuthorityId: offchain::AppCrypto<Self::Public, Self::Signature>;

    /// The overarching dispatch call type.
    type Call: From<Call<Self>>;
    /// The overarching event type.
    type Event: From<Event<Self>> + Into<<Self as system::Trait>::Event>;
}

decl_storage! {
	trait Store for Module<T: Trait> as SgxHelloWorld {
		/// Dummy
		Dummy get(fn prices): Vec<u32>;
	}
}

decl_event!(
	/// Events generated by the module.
	pub enum Event<T> where AccountId = <T as frame_system::Trait>::AccountId {
		/// Event generated when new price is accepted to contribute to the average.
		Dummy(AccountId),
	}
);

decl_module! {
	/// A public part of the pallet.
	pub struct Module<T: Trait> for enum Call where origin: T::Origin {
		fn deposit_event() = default;

		/// Offchain Worker entry point.
		//
		// TODO: handle reorgs and similiar so that the offchain worker just get executed
		// once per block
		fn offchain_worker(block_number: T::BlockNumber) {
			debug::native::info!("SGX OFFCHAIN WORKER; block_number: {}", block_number);

			let signer = offchain::Signer::<T, T::AuthorityId>::all_accounts();
			if !signer.can_sign() {
				debug::native::info!("no signer enabled");
			}

			let body = vec![b"hello sgx from substrate"];
			let pending = http::Request::post("http://127.0.0.1:63003", body)
				.add_header("substrate_sgx", "1.0")
				.send()
				.unwrap();

			let response = pending.wait().expect("http IO error");
			let body: Vec<u8> = response.body().collect();
			let body_str = sp_std::str::from_utf8(&body).expect("body valid utf8");
			debug::native::info!("Intel SGX Enclave response {:?}", body_str);
		}
	}
}

impl<T: Trait> Module<T> {}

#[allow(deprecated)] // ValidateUnsigned
impl<T: Trait> frame_support::unsigned::ValidateUnsigned for Module<T> {
	type Call = Call<T>;

	/// Validate unsigned call to this module.
	///
	/// By default unsigned transactions are disallowed, but implementing the validator
	/// here we make sure that some particular calls (the ones produced by offchain worker)
	/// are being whitelisted and marked as valid.
	fn validate_unsigned(
		_source: TransactionSource,
		_call: &Self::Call,
	) -> TransactionValidity {
		InvalidTransaction::Call.into()
	}
}
